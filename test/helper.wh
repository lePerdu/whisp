(def! *all-tests* (atom nil))
(def! *test-group-prefix* "")

(defrecord! <test-entry>
  make-test-entry
  test-entry?
  (name test-entry-name)
  (func test-entry-func))

(defmacro! (deftest! name . body)
  (let ((label (->string name)))
    `(let ((test-fn (fn-named ~name () ~(cons 'do body))))
      (swap! *all-tests*
        (fn (all-tests)
          (cons
            (make-test-entry
              (string-concat *test-group-prefix* ~label)
              test-fn)
            all-tests))))))

(defmacro! (defgroup! name . body)
  (let ((label (->string name)))
    `(let
      ((*test-group-prefix*
        (string-concat *test-group-prefix* ~label " > ")))
      ~(cons 'do body))))

(defrecord! <test-failure>
  make-test-failure
  test-failure?
  (entry test-failure-entry)
  (error test-failure-error)
  (backtrace test-failure-backtrace))

;; Run a test, returning any error encountered, or nil on success
(defn! (run-test test)
  (do
    (print "RUNNING" (test-entry-name test))
    (print " ... ")
    (flush)
    (guard
      (err
        (do
          (println "FAIL")
          (make-test-failure test err (backtrace))))
      (do
        ((test-entry-func test))
        (println "PASS")
        ; Return nil to indicate no error
        nil))))

(defn! (print-backtrace bt)
  (let-named pbt-loop ((index 0) (bt bt) (prev-fn nil) (rep-count 1))
    (if (null? bt)
      (println)
      (let ((next (car bt)) (rest (cdr bt)))
        (if (= next prev-fn)
          (pbt-loop (inc index) rest next (inc rep-count))
          (do
            (if (> rep-count 1)
              (println #\tab "..." #\tab rep-count "times"))
            (println #\tab index #\tab next)
            (pbt-loop (inc index) rest next 1)))))))

(defn! (run-all-tests)
  (let*
    ((tests-in-order (reverse @*all-tests*))
     (failing-tests-with-results (filter-map run-test tests-in-order))
     (total-count (count @*all-tests*))
     (fail-count (count failing-tests-with-results))
     (pass-count (- total-count fail-count)))
    (do
      ; TODO Clear out tests?
      (newline)
      (println "TESTS RAN:" total-count)
      (println "PASSED:" pass-count)
      (println "FAILED:" fail-count)
      (if (null? failing-tests-with-results)
        (println "ALL TESTS PASSED!")
        (do
          (println "FAILING TESTS:")
          (for-each
            (fn (failed)
              (do
                (println (test-entry-name (test-failure-entry failed)) ":")
                (println (test-failure-error failed))
                (print-backtrace (test-failure-backtrace failed))
                (println)))
            failing-tests-with-results)
          (error 'test-suite-failed))))))

; Assertion helpers

(defn! (assert-make-error expr metadata)
  (error (concat (list 'assert-failed expr) metadata)))

(defmacro! (assert expr . extra)
  `(if (not ~expr)
    (assert-make-error '~expr ~(cons 'list extra))))

(defmacro! (assert= expected actual)
  `(assert (= ~expected ~actual) 'expected ~expected 'got ~actual))

(defmacro! (assert-not= expected actual)
  `(assert (not (= ~expected ~actual)) 'expected-not ~expected))

(defmacro! (assert== expected actual)
  `(assert (== ~expected ~actual) 'expected ~expected 'got ~actual))

(defmacro! (assert-not== expected actual)
  `(assert (not (== ~expected ~actual)) 'expected-not ~expected))

(defmacro! (assert-not-equal expected actual)
  `(assert (not (equal? ~expected ~actual)) 'expected-not ~expected))

(defmacro! (assert-equal expected actual)
  `(assert (equal? ~expected ~actual) 'expected ~expected 'got ~actual))

(defmacro! (assert-error expr)
  `(if (guard (err false) (do ~expr true))
    (assert-make-error '~expr (list 'expected-error))))
