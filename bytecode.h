#ifndef BYTECODE_H_
#define BYTECODE_H_

#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#include "types.h"
#include "val_array.h"

enum bytecode_op {
  /**
   * Load a constant from the constant table.
   *
   * TODO Support more than 256 constants
   *
   * `const INDEX`
   */
  OP_CONST,

  /**
   * Get upvalue at `INDEX` in the current closure.
   *
   * `get-upvalue INDEX`
   */
  OP_GET_UPVALUE,

  /**
   * Copy local at `OFFSET` from the frame pointer to the top of the stack.
   *
   * `get-fp OFFSET`
   */
  OP_GET_FP,

  /**
   * Pops a symbol and a value off the stack tries to resolve that symbol in the
   * global environment. If found, the binding is pushed on the stack; otherwise
   * an error is raised.
   */
  OP_GET_GLOBAL,

  /**
   * Pops a symbol and a value off the stack and binds the symbol to the value
   * in the global environemnt.
   *
   * This is generated by the compiler when compiling top-level definitions so
   * that the compiled closure can define global objects.
   */
  OP_SET_GLOBAL,

  /**
   * Duplicate the top of the stack.
   */
  OP_DUP,

  /**
   * Pops a value off the stack.
   */
  OP_POP,

  /**
   * Delete `N` stack elements after the top `M` elements (and move the top `M`
   * down to fill the gap).
   *
   * `skip-delete M N`
   */
  OP_SKIP_DELETE,

  /**
   * Call the top of the stack with the specified number of arguments.
   *
   * `call N-ARGS`
   */
  OP_CALL,

  /**
   * Clear the stack except for the top value and pop the current call frame.
   *
   * `return`
   */
  OP_RETURN,

  /**
   * Call the top of the stack with all the values on the stack passed as
   * arguments.
   *
   * `tail-call`
   */
  OP_TAIL_CALL,

  /**
   * Allocates a closure with the code chunk from `INDEX` constant table with
   * `N` bound variables.
   *
   * `alloc-closure INDEX N`
   */
  OP_ALLOC_CLOSURE,

  /**
   * Bind `N` upvalues into a closure object. Upvalues are on the top of the
   * stack, followed by the closure. The closure object is left on the stack.
   *
   * TODO Make calling convention for `OP_CALL` work the same way for
   * consistency?
   *
   * `init-closure N`
   */
  OP_INIT_CLOSURE,

  /**
   * Collapse arguments starting at a given FP index into a list.
   *
   * `build-rest-args FP-INDEX`
   */
  OP_BUILD_REST_ARGS,

  /**
   * Call an intrisic by index.
   * These all operate on the stack frame of the current function, but will not
   * create or delete stack frames. Current API limits to 256 intrinsics, but
   * that's probably a good limit anyway.
   *
   * `intrinsic INDEX`
   */
  OP_INTRINSIC,

  /**
   * Branch to another location in the current bytecode chunk.
   *
   * The offset is computed as a signed 2-byte integer relative to the index
   * after the current instruction.
   *
   * `branch OFFSET`
   */
  OP_BRANCH,

  /**
   * Pop the top of the stack and branch if it is falsey (nil).
   *
   * `branch-if-false OFFSET`
   */
  OP_BRANCH_IF_FALSE,

  /**
   * Push the current frame index onto the stack.
   *
   * `get-current-frame`
   */
  OP_GET_CURRENT_FRAME,

  /**
   * Pop a frame index off the stack, and act as if a `OP_RETURN` was executed
   * from that stack frame.
   *
   * `return-from-frame`
   */
  OP_RETURN_FROM_FRAME,
};

struct bytecode_array {
  size_t size;
  size_t cap;
  uint8_t *data;
};

// TODO Pick better name
// TODO Should this be GC'd? It probably always has a single clear owner (i.e. a
// function object)
struct code_chunk {
  struct lisp_obj header;

  /** Function name (if known) for debugging. */
  struct lisp_symbol *name;

  /** File where the function was defined (if known) for debugging. */
  struct lisp_string *filename;

  unsigned req_arg_count;
  bool is_variadic;

  struct val_array const_table;
  // TODO Store bytecode inline with the template allocation?
  struct bytecode_array bytecode;
};

struct code_chunk *chunk_create(void);

bool is_chunk(struct lisp_val v);

/**
 * Return C-string of the name, or a placeholder if unset.
 */
const char *chunk_get_name(const struct code_chunk *chunk);

/**
 * Add a constant to the function's constant table and return its index.
 */
unsigned chunk_add_const(struct code_chunk *chunk, struct lisp_val v);

/**
 * Append a byte to the chunk and return its index.
 */
unsigned chunk_append_byte(struct code_chunk *chunk, uint8_t byte);

/**
 * Set a byte at a specific index.
 */
void chunk_set_byte(struct code_chunk *chunk, unsigned index, uint8_t byte);

unsigned chunk_append_short(struct code_chunk *t, int16_t v);

void chunk_set_short(struct code_chunk *t, unsigned index, int16_t v);

// TODO Implement in lisp?
void chunk_disassemble(const struct code_chunk *chunk);

#endif
