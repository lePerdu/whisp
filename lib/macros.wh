; TODO Support splice-unquote
; TODO Implement as builtin (better perf, plus it may actually be easier since
; mutations are possible)

; Easy way to comment out a bunch of expressions
; It does still have to return a value, so has to be used at top-level or in a
; do block
(defmacro! (comment . ignore) nil)

(defmacro! (let bindings ast)
  ; TODO Check structure
  (cons
    (list 'fn (map car bindings) ast)
    (map cadr bindings)))

; TODO Proper, native support for this
(def! gensym
  (let ((counter (atom 0)))
    (fn opt-name
      (let
        ((name
          (if (null? opt-name)
            ""
            (if (null? (cdr opt-name))
              (string-concat (car opt-name) "__")
              (error "gensym: too many arguments")))))
        (string->symbol
          (string-concat
            "__gensym__"
            name
            (->string (swap! counter inc))))))))

(defsyntax! quasiquote
  (let () (do
    (defn! (process-unquote-args args)
      (if (cons? args)
        (if (null? (cdr args))
          (car args)
          (error "unquote: too many arguments"))
        (error "unquote: not enough arguments")))

    (defn! (is-splice-unquote-form form)
      (if (cons? form)
        (if (= (car form) 'splice-unquote)
          (if (cons? (cdr form))
            (if (null? (cddr form))
              true
              (error "splice-unquote: too many arguments"))
            (error "splice-unquote: not enough arguments")))))

    (def! get-splice-unquote-arg cadr)

    (defn! (qq ast)
      (if (cons? ast)
        (let ((first (car ast)) (rest (cdr ast)))
          (if (= first 'unquote)
            (process-unquote-args rest)
            (if (is-splice-unquote-form first)
              (list
                'concat
                (get-splice-unquote-arg first)
                (qq rest))
              (list 'cons (qq first) (qq rest)))))
        (list 'quote ast)))

    qq)))

(defmacro! (let* bindings ast)
  (do
    (defn! (helper bindings ast)
      (if (null? bindings)
        ast
        `(let (~(car bindings))
          ~(helper (cdr bindings) ast))))
    (if (null? bindings)
      ; Special case for no bindings so that it still generates a new scope
      `(fn () ~ast)
      (helper bindings ast))))

; TODO Validate structure
(defmacro! (cond . branches)
  (if (null? branches)
    nil
    (let*
      ((branch1 (car branches))
       ; Is there a better way to validate in the middle of a let without
       ; nesting lets and adding a bunch of indentation?
       (_ (if (not (= (count branch1) 2))
        (error "cond: branches must be of the form (condition expr)")))
       (cond1 (car branch1))
       (expr1 (car (cdr branch1))))
      (if (= cond1 'else)
        expr1
        `(if ~cond1 ~expr1 ~(cons 'cond (cdr branches)))))))

; Version of let which extracts values from a cons cell
; TODO Allow more than 1 pattern
; TODO Allow nested / more complex patterns
; (let-cons ((first . rest) (list 1 2 3)) expr) -> first=1, rest=(list 2 3)
(defmacro! (let-cons binding body)
  ; TODO Check structure
  (let
    ((bind-pair (car binding))
     (cons-sym (gensym "pair")))
    `(let
      ((~cons-sym ~@(cdr binding)))
      (let
       ((~(car bind-pair) (car ~cons-sym))
        (~(cdr bind-pair) (cdr ~cons-sym)))
       ~body))))

; Version of let-cons which allows an "else" branch if the binding is nil
; TODO Allow more than 1 pattern
; TODO Allow nested / more complex patterns
(defmacro! (let-if-cons binding if-cons . opt-if-nil)
  ; TODO Check structure
  (let
    ((if-nil
      (cond
        ((null? opt-if-nil) nil)
        ((null? (cdr opt-if-nil)) (car opt-if-nil))
        (else (error "let-if-cons: too many arguments"))))
     (bind-pair (car binding))
     (cons-sym (gensym "pair")))
    `(let
      ((~cons-sym ~@(cdr binding)))
      (if (null? ~cons-sym)
        ~if-nil
        (let
         ((~(car bind-pair) (car ~cons-sym))
          (~(cdr bind-pair) (cdr ~cons-sym)))
         ~if-cons)))))

(defmacro! (letrec* bindings body)
  `(let ()
    (do
      ~@(map (fn (b) (cons 'def! b)) bindings)
      ; TODO Add a nested (let () ...) to isolate the bindings?
      ~body)))

; "Named let" from scheme
; TODO Change name? Keep as separate from the basic let?
(defmacro! (let-named name bindings body)
  `(letrec*
    ((~name (fn ~(map car bindings) ~body)))
    (~name ~@(map cadr bindings))))

; TODO Move these?

; Light syntax over with-exception-handler
(defmacro! (guard binding body)
  ; TODO Check structure
  `(with-exception-handler
    ; TODO Use generated symbols to extract sub-expressions
    (fn (~(car binding)) ~@(cdr binding))
    (fn () ~body)))

; Combination of guard and cond to easily match on an error
; TODO Make this the only guard (like in scheme)
(defmacro! (guard-cond conditions body)
  (let-cons ((binding . branches) conditions)
    `(guard
      (~binding
        (cond
          ~@branches
          ; Include re-raise clause if none of the branches match
          (else (raise ~binding))))
      ~body)))

(defn! (macroexpand ast)
  (let ((expanded (macroexpand-1 ast)))
    (if (= expanded ast)
      expanded
      (macroexpand expanded))))
