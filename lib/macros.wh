; TODO Support splice-unquote
; TODO Implement as builtin (better perf, plus it may actually be easier since
; mutations are possible)

; Easy way to comment out a bunch of expressions
; It does still have to return a value, so has to be used at top-level or in a
; do block
(defsyntax! (comment . ignore) nil)

(defsyntax! (let bindings ast)
  ; TODO Check structure
  (cons
    (list 'fn (map car bindings) ast)
    (map cadr bindings)))

; TODO Proper, native support for this
(def! gensym
  (let ((counter (atom 0)))
    (fn ()
      (string->symbol
        (string-concat
          "__gensym__"
          (->string (swap! counter inc)))))))

(defmacro! quasiquote
  (let () (do
    (defn! (process-unquote-args args)
      (if (cons? args)
        (if (null? (cdr args))
          (car args)
          (error "unquote: too many arguments"))
        (error "unquote: not enough arguments")))

    (defn! (is-splice-unquote-form form)
      (if (cons? form)
        (if (= (car form) 'splice-unquote)
          (if (cons? (cdr form))
            (if (null? (cddr form))
              true
              (error "splice-unquote: too many arguments"))
            (error "splice-unquote: not enough arguments")))))

    (def! get-splice-unquote-arg cadr)

    (defn! (qq ast)
      (if (cons? ast)
        (let ((first (car ast)) (rest (cdr ast)))
          (if (= first 'unquote)
            (process-unquote-args rest)
            (if (is-splice-unquote-form first)
              (list
                'concat
                (get-splice-unquote-arg first)
                (qq rest))
              (list 'cons (qq first) (qq rest)))))
        (list 'quote ast)))

    qq)))

(defsyntax! (let* bindings ast)
  (do
    (defn! (helper bindings ast)
      (if (null? bindings)
        ast
        `(let (~(car bindings))
          ~(helper (cdr bindings) ast))))
    (if (null? bindings)
      ; Special case for no bindings so that it still generates a new scope
      `(fn () ~ast)
      (helper bindings ast))))

; Version of let which extracts values from a cons cell
; TODO Allow more than 1 pattern
; TODO Allow nested / more complex patterns
; (let-cons ((first . rest) (list 1 2 3)) expr) -> first=1, rest=(list 2 3)
(defsyntax! (let-cons binding body)
  ; TODO Check structure
  (let
    ((bind-pair (car binding))
     (cons-sym (gensym)))
    `(let
      ((~cons-sym ~@(cdr binding)))
      (let
       ((~(car bind-pair) (car ~cons-sym))
        (~(cdr bind-pair) (cdr ~cons-sym)))
       ~body))))

(defsyntax! (letrec* bindings body)
  `(let ()
    (do
      ~@(map (fn (b) (cons 'def! b)) bindings)
      ; TODO Add a nested (let () ...) to isolate the bindings?
      ~body)))

; TODO Move these?

; Light syntax over with-exception-handler
(defsyntax! (guard binding body)
  ; TODO Check structure
  `(with-exception-handler
    ; TODO Use generated symbols to extract sub-expressions
    (fn (~(car binding)) ~@(cdr binding))
    (fn () ~body)))

; Combination of guard and cond to easily match on an error
; TODO Make this the only guard (like in scheme)
(defsyntax! (guard-cond conditions body)
  (let-cons ((binding . branches) conditions)
    `(guard
      (~binding
        (cond
          ~@branches
          ; Include re-raise clause if none of the branches match
          (else (raise ~binding))))
      ~body)))

(defn! (macroexpand ast)
  (let ((expanded (macroexpand-1 ast)))
    (if (= expanded ast)
      expanded
      (macroexpand expanded))))

; TODO Make error wrap the value somehow
(def! error raise)
