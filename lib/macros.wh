; TODO Support splice-unquote
; TODO Implement as builtin (better perf, plus it may actually be easier since
; mutations are possible)

; Easy way to comment out a bunch of expressions
; It does still have to return a value, so has to be used at top-level or in a
; do block
(defmacro! (comment . ignore) '(do))

(defsyntax! quasiquote
  (let () (do
    (defn! (process-unquote-args args)
      (if (cons? args)
        (if (null? (cdr args))
          (car args)
          (syntax-error "unquote: too many arguments"))
        (syntax-error "unquote: not enough arguments")))

    (defn! (is-splice-unquote-form form)
      (if (cons? form)
        (if (= (car form) 'splice-unquote)
          (if (cons? (cdr form))
            (if (null? (cddr form))
              true
              (syntax-error "splice-unquote: too many arguments"))
            (syntax-error "splice-unquote: not enough arguments")))))

    (def! get-splice-unquote-arg cadr)

    (defn! (qq ast)
      (if (cons? ast)
        (let ((first (car ast)) (rest (cdr ast)))
          (if (= first 'unquote)
            (process-unquote-args rest)
            (if (is-splice-unquote-form first)
              (list
                'concat
                (get-splice-unquote-arg first)
                (qq rest))
              (list 'cons (qq first) (qq rest)))))
        (list 'quote ast)))

    qq)))

(defmacro! (let* bindings ast)
  (do
    (defn! (helper bindings ast)
      (if (null? bindings)
        ast
        `(let (~(car bindings))
          ~(helper (cdr bindings) ast))))
    (if (null? bindings)
      ; Special case for no bindings so that it still generates a new scope
      `(let () ~ast)
      (helper bindings ast))))

; TODO Validate structure
(defmacro! (cond . branches)
  (if (null? branches)
    nil
    (let*
      ((branch1 (car branches))
       ; Is there a better way to validate in the middle of a let without
       ; nesting lets and adding a bunch of indentation?
       (_ (if (not (= (count branch1) 2))
        (syntax-error "branches must be of the form (condition expr)")))
       (cond1 (car branch1))
       (expr1 (car (cdr branch1))))
      (if (= cond1 'else)
        expr1
        `(if ~cond1 ~expr1 ~(cons 'cond (cdr branches)))))))

; TODO Validate structure
(defmacro! (case expr . branches)
  (let*
    ((val-sym (gensym))
     (case-branch-to-cond (fn (branch)
       (cond
         ((list? (car branch))
           `((member= ~val-sym '~(car branch)) ~@(cdr branch)))
         ((= 'else (car branch))
           `(else ~@(cdr branch)))
         (else
           (syntax-error "branches must be of the form ((matches ...) expr)"))))))
    `(let ((~val-sym ~expr))
      (cond ~@(map case-branch-to-cond branches)))))

; Version of let which extracts values from a cons cell
; TODO Allow more than 1 pattern
; TODO Allow nested / more complex patterns
; (let-cons ((first . rest) (list 1 2 3)) expr) -> first=1, rest=(list 2 3)
(defmacro! (let-cons binding body)
  ; TODO Check structure
  (let
    ((bind-pair (car binding))
     (cons-sym (gensym "pair")))
    `(let
      ((~cons-sym ~@(cdr binding)))
      (let
       ((~(car bind-pair) (car ~cons-sym))
        (~(cdr bind-pair) (cdr ~cons-sym)))
       ~body))))

(defmacro! (let-if binding if-true . opt-if-nil)
  (let
    ((bind-sym (car binding))
     (bind-expr (cadr binding))
     ; Bind to a hidden symbol first so that the specified symbol isn't bound in
     ; the "false" branch
     (init-bind-sym (gensym))
     (if-nil (cond
      ((null? opt-if-nil) nil)
      ((null? (cdr opt-if-nil)) (car opt-if-nil))
      (else (syntax-error "too many arguments")))))
    `(let ((~init-bind-sym ~bind-expr))
      (if ~init-bind-sym
        (let ((~bind-sym ~init-bind-sym))
          ~if-true)
        ~if-nil))))

; Version of let-cons which allows an "else" branch if the binding is nil
; TODO Allow more than 1 pattern
; TODO Allow nested / more complex patterns
(defmacro! (let-if-cons binding if-cons . opt-if-nil)
  ; TODO Check structure
  (let
    ((if-nil
      (cond
        ((null? opt-if-nil) nil)
        ((null? (cdr opt-if-nil)) (car opt-if-nil))
        (else (syntax-error "too many arguments"))))
     (bind-pair (car binding))
     (cons-sym (gensym "pair")))
    `(let
      ((~cons-sym ~@(cdr binding)))
      (if (cons? ~cons-sym)
        (let
         ((~(car bind-pair) (car ~cons-sym))
          (~(cdr bind-pair) (cdr ~cons-sym)))
         ~if-cons)
        ~if-nil))))

(defmacro! (letrec* bindings body)
  `(let ()
    (do
      ~@(map (fn (b) (cons 'def! b)) bindings)
      ; TODO Add a nested (let () ...) to isolate the bindings?
      ~body)))

; "Named let" from scheme
; TODO Change name? Keep as separate from the basic let?
(defmacro! (let-named name bindings body)
  `(letrec*
    ((~name (fn ~(map car bindings) ~body)))
    (~name ~@(map cadr bindings))))

; () -> (nil . nil)
; (a b) -> ((a b) . nil)
; (a b . c) -> ((a b) . c)
(defn! (fn-case-split-arg-list arg-list)
  (cond
    ((null? arg-list) '(nil . nil))
    ((cons? arg-list)
      (let-cons ((proper . rest) (fn-case-split-arg-list (cdr arg-list)))
        (cons (cons (car arg-list) proper) rest)))
    (else
      (cons nil arg-list))))

(defn! (fn-case-bind-args args-sym req-args rest-arg expr)
  (if (null? req-args)
    (if (null? rest-arg)
      expr
      `(let ((~rest-arg ~args-sym)) ~expr))
    `(let ((~(car req-args) (car ~args-sym)) (~args-sym (cdr ~args-sym)))
      ~(fn-case-bind-args args-sym (cdr req-args) rest-arg expr))))

(defn! (fn-case-branch-to-cond args-sym arg-count-sym branch)
  (let-cons ((req-args . rest-arg) (fn-case-split-arg-list (car branch)))
    (let
      ((req-arg-count (count req-args))
       (expr (cadr branch))
       (comparator (if (null? rest-arg) 'int= 'int>=)))
      `((~comparator ~arg-count-sym ~req-arg-count)
        ~(fn-case-bind-args args-sym req-args rest-arg (cadr branch))))))

(defmacro! (fn-case . branches)
  (let
    ((args-sym (gensym "args"))
     (args-count-sym (gensym "args-count")))
  ; TODO Find lowest required arg count and make those args
  ; non-variadic to avoid allocating cons cells for those args
  `(fn ~args-sym
    (let ((~args-count-sym (count ~args-sym)))
      (cond
        ~@(map
          (fn (branch)
            (fn-case-branch-to-cond
              args-sym args-count-sym branch))
          branches)
        ; TODO Distinguish between not enough and too many args
        (else (error "fn-case: no matching argument count")))))))

; TODO Change syntax of `defn!` so that it better matches this
; (function name outside parens)?
; - (defn! (f x y) ...)
; - (defn-case! f ((x y) ...))
; TODO Make defn!/defmacro! support both versions?
(defmacro! (defn-case! name . branches)
  `(def! ~name (fn-case ~@branches)))

(defmacro! (defmacro-case! name . branches)
  `(defsyntax! ~name (fn-case ~@branches)))

; Easier-to-use versions of call-with-escape-continuation

(def! call/ec call-with-escape-continuation)

(defmacro! (let/ec esc-cont-name body)
  `(call-with-escape-continuation
    (fn (~esc-cont-name) ~body)))

(defmacro! (for bindings stop-and-return . body)
  (let
    ((loop-sym (gensym))
     (init-exprs (map (fn (b) (take 2 b)) bindings))
     (step-exprs
       (map
         (fn (b)
           (if (null? (cddr b)) (car b) (caddr b)))
         bindings))
     (test-expr (car stop-and-return))
     (return-exprs (cdr stop-and-return)))
  `(let-named ~loop-sym ~init-exprs
    (if ~test-expr
      (do ~@return-exprs)
      (do ~@body (~loop-sym ~@step-exprs))))))

(defn! (macroexpand-1 ast)
  ; Use escape cont to avoid repeating the `false` branch of all the conditions
  (let/ec return
    (do
      (let-if-cons ((head . args) ast)
        (if (symbol? head)
          (let-if (resolved (macro-fn head))
            (if (list? args)
              (return (apply resolved args))))))
      ast)))

(defn! (macroexpand ast)
  (let ((expanded (macroexpand-1 ast)))
    (if (= expanded ast)
      expanded
      (macroexpand expanded))))

