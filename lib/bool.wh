(defn! (true? x) (if x true false))
(defn! (false? x) (if x false true))
(def! not false?)

; Apply f if x is non-nil
(defn! (map-if f x)
  (if x (f x)))

(defsyntax! (unless c f)
  `(if ~c nil ~f))

; TODO Validate structure
(defsyntax! (cond . branches)
  (if (null? branches)
    nil
    (let*
      ((branch1 (car branches))
       ; Is there a better way to validate in the middle of a let without
       ; nesting lets and adding a bunch of indentation?
       (_ (unless (= (count branch1) 2)
        (error "cond: branches must be of the form (condition expr)")))
       (cond1 (car branch1))
       (expr1 (car (cdr branch1))))
      (if (= cond1 'else)
        expr1
        `(if ~cond1 ~expr1 ~(cons 'cond (cdr branches)))))))

; TODO Make these return values? It's useful sometimes and enables these forms
; to be tail-call optimized, but adds in overhead without good optimizations
(defsyntax! (and . conds)
  (if (null? conds)
    true
    `(if ~(car conds) (and ~@(cdr conds)) false)))
(defsyntax! (or . conds)
  (if (null? conds)
    false
    `(if ~(car conds) true (or ~@(cdr conds)))))
(defsyntax! (xor . conds)
  (if (null? conds)
    false
    `(if ~(car conds)
      ; Found a true value, the rest must be false
      (not (or ~@(cdr conds)))
      (xor ~@(cdr conds)))))

(defsyntax! (let-if binding . branches)
  ; TODO Generate temporary symbol so that the binding is not available in the
  ; false branch
  `(let (~binding)
    (if ~(car binding) ~@branches)))

(defsyntax! (let-cond binding . branches)
  `(let (~binding)
    (cond ~@branches)))

; Structural comparison
(defn! (equal? a b)
  (or
    ; Integers, symbols, functions, and atoms
    (= a b)
    ; TODO Use more generic numeric comparison?
    (and (real? a) (real? b) (real= a b))
    (and (char? a) (char? b) (char= a b))
    ; TODO Refactor things so that the string check isn't duplicated?
    ; string= also checks it's argument types
    (and (string? a) (string? b) (string= a b))
    (and
      (cons? a) (cons? b)
      (equal? (car a) (car b)) (equal? (cdr a) (cdr b)))))

