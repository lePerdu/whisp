; Apply f if x is non-nil
(defn! (map-if f x)
  (if x (f x)))

; TODO Make these return values? It's useful sometimes and enables these forms
; to be tail-call optimized, but adds in overhead without good optimizations
(defsyntax! (and . conds)
  (if (null? conds)
    true
    `(if ~(car conds) (and ~@(cdr conds)) false)))
(defsyntax! (or . conds)
  (if (null? conds)
    false
    `(if ~(car conds) true (or ~@(cdr conds)))))
(defsyntax! (xor . conds)
  (if (null? conds)
    false
    `(if ~(car conds)
      ; Found a true value, the rest must be false
      (not (or ~@(cdr conds)))
      (xor ~@(cdr conds)))))

(defsyntax! (let-if binding . branches)
  ; TODO Generate temporary symbol so that the binding is not available in the
  ; false branch
  `(let (~binding)
    (if ~(car binding) ~@branches)))

(defsyntax! (let-cond binding . branches)
  `(let (~binding)
    (cond ~@branches)))

; Structural comparison
(defn! (equal? a b)
  (or
    ; Integers, symbols, functions, and atoms
    (= a b)
    ; TODO Use more generic numeric comparison?
    (and (real? a) (real? b) (real= a b))
    (and (char? a) (char? b) (char= a b))
    ; TODO Refactor things so that the string check isn't duplicated?
    ; string= also checks it's argument types
    (and (string? a) (string? b) (string= a b))
    (and
      (cons? a) (cons? b)
      (equal? (car a) (car b)) (equal? (cdr a) (cdr b)))))

