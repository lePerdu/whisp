; Apply f if x is non-nil
(defn! (map-if f x)
  (if x (f x)))

(defmacro! (and . conds)
  (cond
    ((null? conds) true)
    ((null? (cdr conds)) (car conds))
    (else
      `(if ~(car conds) (and ~@(cdr conds)) false))))
(defmacro! (or . conds)
  (cond
    ((null? conds) false)
    ((null? (cdr conds)) (car conds))
    (else
      (let ((temp-sym (gensym)))
        `(let ((~temp-sym ~(car conds)))
          (if ~temp-sym
            ~temp-sym
            (or ~@(cdr conds))))))))
; TODO Is there a good return value for xor besides true/false?
(defmacro! (xor . conds)
  (if (null? conds)
    false
    `(if ~(car conds)
      ; Found a true value, the rest must be false
      (not (or ~@(cdr conds)))
      (xor ~@(cdr conds)))))

(defmacro! (let-cond binding . branches)
  `(let (~binding)
    (cond ~@branches)))

; Structural comparison
(defn! (equal? a b)
  (or
    ; Integers, symbols, functions, and atoms
    (= a b)
    ; TODO Use more generic numeric comparison?
    (and (real? a) (real? b) (real= a b))
    (and (char? a) (char? b) (char= a b))
    ; TODO Refactor things so that the string check isn't duplicated?
    ; string= also checks it's argument types
    (and (string? a) (string? b) (string= a b))
    (and
      (cons? a) (cons? b)
      (equal? (car a) (car b)) (equal? (cdr a) (cdr b)))))

