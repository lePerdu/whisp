; TODO Figure out ideal bit count. Keeping it smaller for now since it makes
; depth-related bugs surface earlier
(def! *vector-trie-bits* 4)
(def! *vector-trie-width* (bitshift 1 *vector-trie-bits*))
(def! *vector-trie-mask* (int- *vector-trie-width* 1))

(defrecord! <vector>
  ; Only "export" vector-length and vector?
  ; TODO Decide on private export syntax/convention (or just wait for real modules)
  _build-vector
  vector?
  (length vector-length _vector-length-set)
  (shift _vector-shift _vector-shift-set)
  (root _vector-root _vector-root-set))

(def! empty-vector (_build-vector 0 0 (array)))

(defn! (_vector-check-bounds v i)
  (<= 0 i (dec (vector-length v))))

(defn! (_vector-dec-bits level) (int- level *vector-trie-bits*))
(defn! (_vector-inc-bits level) (int+ level *vector-trie-bits*))

(defn! (_vector-level-index i level)
  (bitand
    (bitshift i (int- 0 level))
    *vector-trie-mask*))

; Resolve the underlying array
(defn! (_vector-find-node v i)
  (if (_vector-check-bounds v i)
    (let-named search-iter
      ((level (_vector-shift v)) (node (_vector-root v)))
      (if (= level 0)
        node
        (search-iter
          (_vector-dec-bits level)
          (array-get node (_vector-level-index i level)))))
    (error "vector-get: index out of bounds")))

(defn! (vector-get v i)
  (let ((node (_vector-find-node v i)))
    (array-get node (bitand i *vector-trie-mask*))))

; Destructive set
(defn! (vector-set! v i value)
  (let ((node (_vector-find-node v i)))
    (array-set! node (bitand i *vector-trie-mask*) value)))

; Persistent set (returns a new vector)
(defn! (vector-set v i value)
  (if (_vector-check-bounds v i)
    (do
      (defn! (trie-set level node)
        (let ((cur-index (_vector-level-index i level)))
          (array-set
            node
            cur-index
            (if (= level 0)
              value
              (trie-set
                (_vector-dec-bits level)
                (array-get node cur-index))))))

      (_vector-root-set v
        (trie-set (_vector-shift v) (_vector-root v))))
    (error "vector-get: index out of bounds")))

(defn! (make-new-branch shift single-elem)
  ; TODO Make iterative?
  (let-named rec ((level shift))
    (if (= level 0)
      single-elem
      (array (rec (int- level *vector-trie-bits*))))))

(defn! (vector-append v value)
  (do
    (def! len (vector-length v))
    (defn! (last-child-full? node level)
      (=
        (_vector-level-index len level)
        (bitand (array-length node) *vector-trie-mask*)))
    (defn! (trie-append shift node)
      (if (last-child-full? node shift)
        (array-append
          node
          (make-new-branch shift value))
        (let ((last-index (dec (array-length node))))
          (array-set
            node
            last-index
            (trie-append
              (int- shift *vector-trie-bits*)
              (array-get node last-index))))))

    (let*
      ((root (_vector-root v))
       (shift (_vector-shift v))
       (root-full?
        (and
          (= (array-length root) *vector-trie-width*)
          (last-child-full? root shift))))
      (if root-full?
        (let ((new-shift (_vector-inc-bits shift)))
          (_build-vector
            (inc len)
            new-shift
            (array root (make-new-branch new-shift value))))
        (_build-vector
          (inc len)
          shift
          (trie-append shift root))))))

(defn! (_array-pop-or-nil arr)
  (if (= (array-length arr) 1)
    nil
    (array-sub arr 0 (dec (array-length arr)))))

(defn! (vector-pop v)
  (let*
    ((new-len (dec (vector-length v)))
     (shift (_vector-shift v))
     (new-root
      (let-named trie-pop ((level shift) (node (_vector-root v)))
        (if (= level 0)
          (_array-pop-or-nil node)
          (let*
            ((last-index (dec (array-length node)))
             (new-last-node
              (trie-pop
                (int- level *vector-trie-bits*)
                (array-get node last-index))))
            (if (null? new-last-node)
              (_array-pop-or-nil node)
              (array-set node last-index new-last-node)))))))
    (cond
      ; Vector is empty, so re-use the global instance
      ((null? new-root) empty-vector)
      ; Delete a level if possible
      ((and (int> shift 0) (= (array-length new-root) 1))
        (_build-vector
          new-len
          (int- shift *vector-trie-bits*)
          (array-get new-root 0)))
      (else (_build-vector new-len shift new-root)))))

(defn! (vector-equal? a b)
  (let ((a-len (vector-length a)))
    (and
      (= a-len (vector-length b))
      (let-named loop ((i 0))
        (or
          (= i a-len)
          (and
            (equal? (vector-get a i) (vector-get b i))
            (loop (inc i))))))))

; TODO More efficient tree iteration

(defn! (list->vector lst)
  (foldl empty-vector vector-append lst))

(defn! (vector->list v)
  (let-named loop ((acc nil) (index (dec (vector-length v))))
    (if (= index -1)
      acc
      (loop
        (cons (vector-get v index) acc)
        (dec index)))))

(defn! (vector . elems) (list->vector elems))

(defn! (vector-fold init f v)
  (let ((end-index (vector-length v)))
    (let-named loop ((acc init) (index 0))
      (if (= index end-index)
        acc
        (loop (f acc (vector-get v index)) (inc index))))))

(defn! (vector-concat . vs)
  (if (null? vs)
    empty-vector
    ; Easy optimization: use the first vector as a starting point to avoid
    ; reconstructing it
    (foldl
      (car vs)
      (fn (v1 v2) (vector-fold v1 vector-append v2))
      (cdr vs))))

; TODO More efficient tree structure copying?
; At least for vector-map, the resulting vector will have the same structure,
; so the extra work done to figure out where to insert things is unnecessary

(defn! (vector-map f v)
  (vector-fold
    empty-vector
    (fn (acc x) (vector-append acc (f x)))
    v))

(defn! (vector-sub v start-index end-index)
  (let-named loop ((acc empty-vector) (index start-index))
    (if (= index end-index)
      acc
      (loop (vector-append acc (vector-get v index)) (inc index)))))
