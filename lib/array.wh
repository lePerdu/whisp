(def! empty-array (make-array 0))

(defn! (list->array elems)
  (let* ((n (count elems)) (arr (make-array n)))
    (let-named loop
      ((i 0) (rest elems))
      (if (= i n)
        arr
        (do
          (array-set! arr i (car rest))
          (loop (inc i) (cdr rest)))))))

(defn! (array->list arr)
  (let-named loop ((acc nil) (index (dec (array-length arr))))
    (if (= index -1)
      acc
      (loop
        (cons (array-get arr index) acc)
        (dec index)))))

; TODO Include in equal?
(defn! (array-equal? a b)
  (let ((a-len (array-length a)))
    (and
      (= a-len (array-length b))
      (let-named loop ((i 0))
        (or (= i a-len)
          (and
            (equal? (array-get a i) (array-get b i))
            (loop (inc i))))))))

; TODO More generic array-compare?

(defn! (array . elems) (list->array elems))

(defn! (array-update! arr i f)
  (array-set! arr i (f (array-get arr i))))

;; Persistent operations which return new array instead of mutating

(defn! (array-map f arr)
  (let* ((n (array-length arr)) (new (make-array n)))
    (let-named loop ((i 0))
      (if (= i n)
        new
        (do
          (array-set! new i (f (array-get arr i)))
          (loop (inc i)))))))

; TODO Define as primitive? Then it can be a simple alloc + memcpy
(defn! (array-copy arr) (array-map identity arr))

; Persistent set (returns a new array)
(defn! (array-set arr i value)
  (let ((copy (array-copy arr)))
    (do
      (array-set! copy i value)
      copy)))

(defn! (array-update arr i f)
  (array-set arr i (f (array-get arr i))))

; Persistent append
(defn! (array-append arr value)
  (let*
    ((old-len (array-length arr))
     (new-arr (make-array (inc old-len))))
    (let-named loop ((i 0))
      (if (= i old-len)
        (do
          (array-set! new-arr i value)
          new-arr)
        (do
          (array-set! new-arr i (array-get arr i))
          (loop (inc i)))))))

(defn! (array-copy-sub from into start end into-offset)
  (if (= start end)
    into
    (do
      (array-set!
        into
        (int+ start into-offset)
        (array-get from start))
      (array-copy-sub from into (inc start) end into-offset))))

(defn! (array-sub arr start end)
  (array-copy-sub
    arr
    (make-array (int- end start))
    start
    end
    (int- 0 start)))

(defn! (array-concat . arrays)
  (let*
    ((total-len
      (foldl 0
        (fn (acc sub-arr)
          (int+ acc (array-length sub-arr)))
        arrays))
     (new-arr (make-array total-len)))
    (let-named loop ((offset 0) (arrays arrays))
      (let-if-cons ((sub-arr . rest) arrays)
        (let ((sub-arr-len (array-length sub-arr)))
          (do
            (array-copy-sub
              sub-arr new-arr 0 sub-arr-len offset)
            (loop (int+ offset sub-arr-len) (cdr rest))))
        new-arr))))
