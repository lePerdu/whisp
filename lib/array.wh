(def! empty-array (array-alloc 0))

(defn! (list->array elems)
  (let ((arr (array-alloc (count elems))))
    (do
      (for-each-index
        (fn (x index) (array-set! arr index x))
        elems)
      arr)))

(defn! (array->list arr)
  (let-named loop ((acc nil) (index (dec (array-length arr))))
    (if (= index -1)
      acc
      (loop
        (cons (array-get arr index) acc)
        (dec index)))))

; TODO Include in equal?
(defn! (array-equal? a b)
  (let ((a-len (array-length a)))
    (and
      (= a-len (array-length b))
      (let-named loop ((i 0))
        (or (= i a-len)
          (and
            (equal? (array-get a i) (array-get b i))
            (loop (inc i))))))))

; TODO More generic array-compare?

(defn! (array . elems) (list->array elems))

(defn! (array-update! arr i f)
  (array-set! arr i (f (array-get arr i))))

;; Persistent operations which return new array instead of mutating

;; Helper for functions with optional bounds
(defmacro! (defn-with-array-range! name req-args array-arg start-arg end-arg delegate)
  `(defn-case! ~name
    (~req-args
      (~delegate ~@req-args 0 (array-length ~array-arg)))
    ((~@req-args ~start-arg)
      (~delegate ~@req-args ~start-arg (array-length ~array-arg)))
    ((~@req-args ~start-arg ~end-arg)
      (~delegate ~@req-args ~start-arg ~end-arg))))

; TODO Define as primitive? Then it can be a simple memcpy
(defn! (array-copy-sub from into start end into-offset)
  (if (int>= start end)
    into
    (do
      (array-set!
        into
        (int+ start into-offset)
        (array-get from start))
      (array-copy-sub from into (inc start) end into-offset))))

(defn-with-array-range! array-copy (arr) arr start end array-copy-helper)
(defn! (array-copy-helper arr start end)
  (array-copy-sub
    arr
    (array-alloc (int- end start))
    start
    end
    (int- 0 start)))

(defn! (array-map f arr)
  (let* ((n (array-length arr)) (new (array-alloc n)))
    (let-named loop ((i 0))
      (if (= i n)
        new
        (do
          (array-set! new i (f (array-get arr i)))
          (loop (inc i)))))))

; Persistent set (returns a new array)
(defn! (array-set arr i value)
  (let ((copy (array-copy arr)))
    (do
      (array-set! copy i value)
      copy)))

(defn! (array-update arr i f)
  (array-set arr i (f (array-get arr i))))

; Persistent append
(defn! (array-append arr value)
  (let*
    ((old-len (array-length arr))
     (new-arr (array-alloc (inc old-len))))
    (let-named loop ((i 0))
      (if (= i old-len)
        (do
          (array-set! new-arr i value)
          new-arr)
        (do
          (array-set! new-arr i (array-get arr i))
          (loop (inc i)))))))

(defn! (array-concat . arrays)
  (let*
    ((total-len
      (foldl 0
        (fn (acc sub-arr)
          (int+ acc (array-length sub-arr)))
        arrays))
     (new-arr (array-alloc total-len)))
    (let-named loop ((offset 0) (arrays arrays))
      (let-if-cons ((sub-arr . rest) arrays)
        (let ((sub-arr-len (array-length sub-arr)))
          (do
            (array-copy-sub
              sub-arr new-arr 0 sub-arr-len offset)
            (loop (int+ offset sub-arr-len) rest)))
        new-arr))))

(defn-with-array-range! array-for-each (f arr) arr start end
  array-for-each-helper)
(defn! (array-for-each-helper f arr start end)
  (let-named loop ((index start))
    (if (int>= index end)
      nil
      (do
        (f (array-get arr index))
        (loop (inc index))))))

(defn-with-array-range! array-for-each-index (f arr) arr start end
  array-for-each-index-helper)
(defn! (array-for-each-index-helper f arr start end)
  (let-named loop ((index start))
    (if (int>= index end)
      nil
      (do
        (f index (array-get arr index))
        (loop (inc index))))))

(defn-with-array-range! array-foldl (init f arr) arr start end
  array-foldl-helper)
(defn! (array-foldl-helper init f arr start end)
  (let-named loop ((acc init) (index start))
    (if (int>= index end)
      acc
      (loop
        (f acc (array-get arr index))
        (inc index)))))

(defn-with-array-range! array-foldr (init f arr) arr start end
  array-foldr-helper)
(defn! (array-foldr-helper init f arr start end)
  (let-named loop ((acc init) (index (dec end)))
    (if (int< index start)
      acc
      (loop
        (f (array-get arr index) acc)
        (dec index)))))

(defn-with-array-range! array-fill! (arr fill) arr start end
  array-fill-helper!)
(defn! (array-fill-helper! arr fill start end)
  (array-for-each-index
    (fn (index _) (array-set! arr index fill))
    arr
    start
    end))

(defn-case! make-array
  ((length) (array-alloc length))
  ((length fill)
    (let ((arr (array-alloc length)))
      (do
        (array-fill! arr fill)
        arr))))
