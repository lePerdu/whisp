; TODO Should these be the builtins? (they are more useful than display and
; newline and more efficient to implement as builtins)

(defn! (string-null? s) (= (string-count s) 0))

(defn! (string->list str) (do
  (defn! (rec acc index)
    (if (= index 0)
      acc
      (let ((i (dec index)))
        (rec (cons (string-get str i) acc) i))))
  (rec nil (string-count str))))

(defn! (char->string chr)
  (if (char? chr)
    (->string chr)
    (error "char->string: must be of type char")))

; TODO These are very inefficient as non-builtins since they allocate a lot of
; intermediate strings

(defn! (list->string lst)
  (apply string-concat (map char->string lst)))

(defn! (substring str . opt-start-end) (do
  (def! n-extra (count opt-start-end))

  (def! start
    (if (>= n-extra 1)
      (car opt-start-end)
      0))
  (def! end
    (if (>= n-extra 2)
      (cadr opt-start-end)
      (string-count str)))

  ; TODO Bounds checking
  (defn! (rec acc index)
    (if (= index end)
      acc
      (rec
        (string-concat acc (->string (string-get str index)))
        (inc index))))

  (if (> n-extra 2)
    (error "substring: too many arguments"))
  (rec "" start)))

(defn! (string-index-helper s pred start end)
  (cond
    ((= start end) nil)
    ((pred (string-get s start)) start)
    (else (string-index-helper s pred (inc start) end))))

(defn! (string-index s pred)
  (string-index-helper s pred 0 (string-count s)))

(defn! (string-rindex-helper s pred start end)
  (let ((end-index (dec end)))
    (cond
      ((= start end) nil)
      ((pred (string-get s end-index)) end-index)
      (else (string-rindex-helper s pred start end-index)))))

(defn! (string-rindex s pred)
  (string-rindex-helper s pred 0 (string-count s)))

(defn! (char-blank? c)
  (or
    (char= c #\space)
    (char= c #\tab)
    (char= c #\newline)))

(defn! (char-non-blank? c)
  (not (char-blank? c)))

(defn! (string-index-or-end s pred)
  (or (string-index s pred) (string-count s)))

(defn! (string-rindex-or-start s pred)
  (or (string-rindex s pred) -1))

(defn! (string-trim-left s)
  (let
    ((start (string-index-or-end s char-non-blank?)))
    (substring s start)))

(defn! (string-trim-right s)
  (let
    ((end (string-rindex-or-start s char-non-blank?)))
    (substring s 0 (inc end))))

(defn! (string-trim s)
  (let ((start (string-index-or-end s char-non-blank?)))
    (if (= start (string-count s))
      ""
      (let ((end (string-rindex-or-start s char-non-blank?)))
        (substring s start (inc end))))))

(defn! (string-opt-range-or-default opt-range-list s)
  (cond
    ((null? opt-range-list)
      (cons 0 (string-count s)))
    ((null? (cdr opt-range-list))
      (cons (car opt-range-list) (string-count s)))
    ((null? (cddr opt-range-list))
      (cons (car opt-range-list) (cadr opt-range-list)))))

(defn! (string-for-each f s . opt-range)
  (let-cons ((start . end) (string-opt-range-or-default opt-range s))
    (let-named loop ((index start))
      (if (< index end)
        (do
          (f (string-get s index))
          (loop (inc index)))))))

(defn! (string-for-each-index f s . opt-range)
  (let-cons ((start . end) (string-opt-range-or-default opt-range s))
    (let-named loop ((index start))
      (if (< index end)
        (do
          (f index (string-get s index))
          (loop (inc index)))))))

(defn! (string-foldl init f s . opt-range)
  (let-cons ((start . end) (string-opt-range-or-default opt-range s))
    (let-named loop ((acc init) (index start))
      (if (>= index end)
        acc
        (loop
          (f acc (string-get s index))
          (inc index))))))

(defn! (string-foldr init f s . opt-range)
  (let-cons ((start . end) (string-opt-range-or-default opt-range s))
    (let-named loop ((acc init) (index (dec end)))
      (if (< index start)
        acc
        (loop
          (f (string-get s index) acc)
          (dec index))))))
